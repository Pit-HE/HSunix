
MAKE 命令使用说明：
    make build   编译 HSunix 系统内核
    make app     编译用户空间代码
    make         执行整个项目代码的清理、编译、链接流程
    make qemu    调用 qemu 直接运行生成的 HSunix 系统文件
    make clean   清除编译时生成的中间文件
    make remove  清除所有生成的文件
    make debug   用于对内核源代码进行 debug 


Makefile 框图说明：
    1、根目录下的 Makefile 主要负责调用各个子目录下的 Makefile 目标，
            以及提供编译时使用到的相关工具与参数信息
    2、kernel 目录下的 makefile 主要负责 HSunix 内核的编译与链接
    3、mkfs 目录下的 makefile 主要负责磁盘工具的编译，以及磁盘 fs.img 
            文件的生成
    4、user 目录下的 makefile 主要负责管理用户空间文件的编译链接与生成


文件夹结构体说明：
    kernel：用于存放 HSunix 内核的所有源码，以及编译生成的文件，
            整个系统在内核空间中执行的内容，都存放在该目录
    mkfs:   用于存放生成挂载到 qemu 上的磁盘文件，属于磁盘文件生成
            的工具
    tools： 存放当前这个系统可能用到的工具
    user：  用于存放执行在用户层的源代码，与 kernel 是分隔开编译的，
            在当前目录下编译、链接生成的文件，最终会通过 mkfs 工具写到
            fs.img 磁盘中


当前系统的特性：
1、文件系统
        1）：拥有一个虚拟文件系统，负责管理不同实际文件系统的适配与管理
        2）：适配 XV6 的磁盘文件系统，可以通过生成 fs.img 文件挂载到 qemu 
             后再通过该文件系统对其中的内容进行操作
        3）：ramfs 文件系统，这是一个使用内存来存储数据的文件系统，掉电后数据
             自动清空，可以用于存放一些动态数据
        4）：文件系统的挂载功能，当注册到虚拟文件系统的具体文件系统可以挂载到
             指定的文件路径中，与普通linux文件系统的挂载类似，当前 ramfs 文件
             系统支持多次挂载功能
        5）：文件系统设备管理模块，注册到当前虚拟文件系统的具体文件系统，都会被
             抽象成文件系统设备，由该模块对其功能进行操作与管理

2、软件定时器：
        1）：当前操作系统具有一个简单的软件定时器模块，该模块通过系统时基进行管理，
             支持定时器对象的创建与删除，目前主要用于提供内核的 sleep 与 wakeup
             功能

3、elf 解析：
        1）：当前操作系统支持解析 elf 文件，主要用于在进程 fork 时加载磁盘文件系统
             中的进程代码
        2）：当前 elf 文件主要是通过 fs.img 文件挂载到 qemu 中后进行读写的，也就是
             当前系统所依赖的文件系统主要是 fs.img

4、内存管理单元（MMU）：
        1）：当前操作系统已支持 risc-v 内存管理单元的 Sv39 类型
        2）：在系统的 vm.c 中主要管理 mmu 模块的基本功能，包括虚拟页表的创建、销毁
             物理内存与虚拟内存的映射、不同页表数据的拷贝等等
        3）：已实现用户进程的虚拟页表管理，当系统从内核空间切换到用户空间的代码时，
             会切换相应的进程虚拟页表，确保每一个进程只执行在其有效的内存空间

5、权限模式切换：
        1）：当前操作系统主要适配 risc-v 架构，所以目前支持三种权限模式的管理：
             机器模式、特权级模式、用户模式
        2）：当前操作系统已实现特权模式与用户模式之间的正常切换，用户模式通过执行
             内核提供的系统调用进入内核空间
        3）：当前操作系统已支持 mmu 功能，在切换到用户模式时，会自动切换成该进程
             所拥有的虚拟页表，实现每一个进程程序的安全管理

6、用户空间管理：
        1）：当前操作系统将用户空间的代码与内核空间的代码进行了隔离，仅通过 qemu 
             的磁盘模块进行交互
        2）：当前系统的用户空间代码全都存放在 user 目录中，在编译过程中不与内核代码
             产生任何的交集，独立编译成对应的可执行文件
        3）：用户空间的代码通过调用 mkfs 中的磁盘文件工具，生成最终的磁盘 fs.img 文件
             件，系统内核中的磁盘文件系统对该磁盘文件进行加载与读取
        4）：用户空间若是想进入内核空间，目前只能通过内核提供的系统调用接口来进行切换


