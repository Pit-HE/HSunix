
环境说明：
     编译环境：
     1、当前 HSunix 运行在riscv64的架构上，
     2、需要用到riscv64的编译工具：riscv64-linux-gnu-
     3、由于 ubunut 没有自带 riscv64 的交叉编译工具，
        为了方便安装该工具链，建议使用 ubuntu 20.04 以上的版本

     开发环境：
     1、当前 HSunix 是通过 qemu 模拟的riscv64虚拟开发板来运行
        后续根据需要移植到riscv64芯片的实际开发板中
     2、该开发板支持 mmu、uart、time 和 virtio 四个外设模块，
        当前 HSunix 也仅用到这四个外设模块进行开发
     3、调试时需要使用 qemu 的调试支持与 gdb 工具的配合

     运行环境：
     1、HSunix 调用 qemu 时，需要直接占用128M的内存空间，
        作为虚拟 riscv64 开发板的运行内存
     2、在创建磁盘文件系统镜像 fs.img 时，默认生成的文件大小为 
        2000*1024 个字节，该文件主要作为 HSunix 运行时的磁盘空间
     3、目前 HSunix 未适配多核的工作环境，该功能后续按照需要再进行
        工程结构的调整来做适配


make 命令说明：
    make build   编译系统内核与用户空间代码，重新创建 fs.img 文件
    make kernel  编译系统内核代码
    make app     编译用户空间代码
    make         执行项目代码清理、编译、链接的完整流程流程
    make qemu    调用 qemu 直接运行生成的 HSunix 系统文件
    make clean   清除编译时生成的中间文件
    make remove  清除所有生成的文件
    make debug   用于对内核源代码进行 debug
    make install 自动安装 HSunix 所需的开发环境与运行环境
    make statis  查看当前项目有效代码的总行数


Makefile 框图说明：
    1、根目录下的 Makefile 主要负责调用各个子目录下的 Makefile 目标，
            以及提供编译时使用到的相关工具与参数信息
    2、kernel 目录下的 makefile 主要负责 HSunix 内核的编译与链接
    3、mkfs 目录下的 makefile 主要负责磁盘工具的编译，以及生成用于挂载到
            qemu 磁盘模块上的 fs.img 文件系统镜像
    4、user 目录下的 makefile 主要负责管理用户空间文件的编译链接与生成


文件夹说明：
     kernel：用于存放 HSunix 内核的所有源码，以及编译生成的文件，
             整个系统在内核空间中执行的内容，都存放在该目录
     mkfs: 用于存放生成挂载到 qemu 上的磁盘文件，属于磁盘文件生成
           的工具
     tools：存放当前这个系统可能用到的工具
     user：用于存放执行在用户层的源代码，与 kernel 是分隔开编译的，
           在当前目录下编译、链接生成的文件，最终会通过 mkfs 工具将用户空间的
           所有代码与文件写入到 fs.img 文件系统镜像中


系统的特性：
1、文件系统
     1）：目前有三个文件系统：虚拟文件系统、ramfs文件系统、diskfs磁盘文件系统
     2）：virtaulfs: 虚拟文件系统主要用于抽象出文件系统的通用功能，提供挂载接
          口管理各个具体文件系统(ramfs\diskfs)的挂载与操作
     3）：diskfs：适配 XV6 的磁盘文件系统，可以通过 qemu 的磁盘模块操作挂载在
          其上的 fs.img 文件系统镜像
     4）：ramfs：内存文件系统，这是一个使用内存来存储数据的文件系统，
          关机后数据自动清空，可以用于存放一些动态数据
     5）：挂载功能： 注册到虚拟文件系统的文件系统设备可以挂载到指定的路径中，
          与 linux 文件系统的挂载类似，当前 ramfs 文件系统支持多次挂载
     6）：文件系统设备管理模块，注册到当前虚拟文件系统的具体文件系统，都会被
          抽象成文件系统设备，由该模块对其功能进行操作与管理

2、进程：
   进程同步：
     1）：进程可以调用接口进入休眠，休眠计数的单位是毫秒
          函数接口为：sleep 
     2）：可以调用接口将进程挂起或唤醒，管理 CPU 的使用权
          函数接口为：suspend / resume
   进程管理：
     3）：fork 接口，复制当前进程，生成新的自进程
     4）：wait 接口，由父进程调用，等待子进程退出
     5）：exit 接口，进程自身调用，退出执行并释放自身占用的资源
     6）：kill 接口，停止指定 ID 的进程，并释放其占用的资源
     7）：exec 接口，加载已经存在的代码，到当前进程空间并执行
     (更多系统调用接口，可以查看 syscall.h 文件了解)
     ... ... 

3、线程：
     1）：当前操作系统的内核线程与用户线程是一对多的关系
   内核线程：
     2）：init 进程：是操作系统的第一个用户进程，也是后续所有进程的父进程
     3）：idle 线程，是操作系统的第一个内核线程，用于处理进程的调度与死亡进程的回收
          该进程未映射相关的用户线程，只运行在操作系统的内核态中
   用户线程：
     4）：当前操作系统提供精简的用户空间线程库，包含创建、退出、等待与休眠功能
     5）：该线程的库的接口与 linux 的 pthread 类似，但目前未支持属性设置
          ( 线程库所提供的接口，可以查看 libc.h )

4、虚拟内存页：
     1）：当前操作系统已支持 risc-v 内存管理单元的 Sv39 类型
     2）：在系统的 vm.c 中主要管理 mmu 模块的基本功能，包括虚拟页表的创建、
          销毁物理内存与虚拟内存的映射、不同页表数据的拷贝等等
     3）：已实现用户进程的虚拟页表管理，当系统从内核空间切换到用户空间的代码时，
          会切换相应的进程虚拟页表，确保每一个进程只执行在其有效的内存空间

5、内存管理：
     1）：当前操作系统内核空间中，支持物理内存页（4096字节）的动态申请与释放
          函数接口为： alloc_page / free_page
     2）：当前操作系统内核空间中，支持小于4096字节的物理内存的动态申请与释放
          函数接口为： kalloc / kfree 
     3）：当前操作系统用户空间中，支持小于4096字节的物理内存的动态申请与释放
          函数接口为： malloc / free 

6、权限模式切换：
     1）：当前操作系统主要适配 risc-v 架构，所以目前支持三种权限模式的管理：
          机器模式、特权级模式、用户模式
     2）：当前操作系统已实现特权模式与用户模式之间的正常切换，用户模式通过执行
          内核提供的系统调用进入内核空间
     3）：当前操作系统已支持 mmu 功能，在切换到用户模式时，会自动切换成该进程
          所拥有的虚拟页表，实现每一个进程程序的安全管理

7、用户空间：
     1）：当前操作系统将用户空间的代码与内核空间的代码进行了隔离，仅通过 qemu 
          的磁盘模块进行交互
     2）：当前系统的用户空间代码全都存放在 user 目录中，在编译过程中不与内核代码
          产生任何的交集，独立编译成对应的可执行文件
     3）：用户空间的代码通过调用 mkfs 中的磁盘文件工具，生成最终的 fs.img 文件系统
          镜像，系统内核中的磁盘文件系统主要用于操作该镜像文件
     4）：用户空间若是想进入内核空间，目前只能通过内核提供的系统调用接口来进行切换

8、elf 解析：
     1）：当前操作系统支持解析 elf 文件，主要用于在进程 fork 时加载磁盘文件系统
          中的进程代码
     2）：当前操作系统的 elf 文件都存放在文件系统镜像(fs.img)中，通过将文件系统
          镜像 fs.img 挂载到 qemu 的磁盘驱动模块之后再读取

9、消息队列：
     1）：提供与 Linux 一致的消息队列接口，使用方法也与 Linux 类似 
     2）：但功能是精简版，目前仅支持进程间的数据传输，不支持控制功能
     3）：对于传输的消息数量与大小没有限制，除非内存被消耗完

10、软件定时器：
     1）：当前操作系统具有简单的软件定时器，由系统时基提供定时器心跳
     2）：支持定时器对象的创建与删除，目前主要用于实现内核的 sleep 与 wakeup
