
环境说明：
     编译环境：
     1、当前 HSunix 运行在riscv64的架构上，
     2、需要用到riscv64的编译工具：riscv64- linux - gnu - xxx 
     3、由于 ubunut 没有自带 riscv64 的交叉编译工具，
        为了方便安装该工具链，建议使用 ubuntu 22.04

     开发环境：
     1、当前 HSunix 是通过 qemu 模拟的riscv64虚拟开发板来运行
        后续根据需要移植到riscv64芯片的实际开发板中
     2、该开发板支持 mmu 、 uart 、 time 和 virtio 四个外设模块，
        当前 HSunix 也仅用到这四个外设模块进行开发
     3、调试时需要使用 qemu 的调试支持与 gdb 工具的配合

     运行环境：
     1、HSunix 调用 qemu 时，需要直接占用128M的内存空间，
        作为虚拟riscv64开发板的运行内存
     2、在创建用于挂载到 qemu 的磁盘文件 fs.img 时，默认直接创建
        的文件大小为 2000*1024 个字节，作为 HSunix 的磁盘空间
     3、目前 HSunix 未适配多核的工作环境，该功能后续按照需要再进行
        工程结构的调整来做适配


MAKE 命令使用说明：
    make build   编译 HSunix 系统内核
    make app     编译用户空间代码
    make         执行整个项目代码的清理、编译、链接流程
    make qemu    调用 qemu 直接运行生成的 HSunix 系统文件
    make clean   清除编译时生成的中间文件
    make remove  清除所有生成的文件
    make debug   用于对内核源代码进行 debug
    make install 自动安装 HSunix 所需的开发环境与运行环境


Makefile 框图说明：
    1、根目录下的 Makefile 主要负责调用各个子目录下的 Makefile 目标，
            以及提供编译时使用到的相关工具与参数信息
    2、kernel 目录下的 makefile 主要负责 HSunix 内核的编译与链接
    3、mkfs 目录下的 makefile 主要负责磁盘工具的编译，以及磁盘 fs.img 
            文件的生成
    4、user 目录下的 makefile 主要负责管理用户空间文件的编译链接与生成


文件夹说明：
     kernel：用于存放 HSunix 内核的所有源码，以及编译生成的文件，
             整个系统在内核空间中执行的内容，都存放在该目录
     mkfs: 用于存放生成挂载到 qemu 上的磁盘文件，属于磁盘文件生成
           的工具
     tools：存放当前这个系统可能用到的工具
     user：用于存放执行在用户层的源代码，与 kernel 是分隔开编译的，
           在当前目录下编译、链接生成的文件，最终会通过 mkfs 工具写到
           fs.img 磁盘中
     


当前系统的特性：
1、文件系统
     1）：目前有三个文件系统：虚拟文件系统、ramfs文件系统、diskfs磁盘文件系统
     2）：virtaulfs: 虚拟文件系统主要用于抽象出文件系统的通用功能，提供挂载接
          口管理各个具体文件系统(ramfs\diskfs)的挂载与操作
     3）：diskfs：适配 XV6 的磁盘文件系统，可以通过生成 fs.img 文件挂载到 
          qemu 后再通过该文件系统对其中的内容进行操作
     4）：ramfs：内存文件系统，这是一个使用内存来存储数据的文件系统，
          关机后数据自动清空，可以用于存放一些动态数据
     5）：挂载功能： 注册到虚拟文件系统的文件系统设备可以挂载到指定的路径中，
          与 linux 文件系统的挂载类似，当前 ramfs 文件系统支持多次挂载
     6）：文件系统设备管理模块，注册到当前虚拟文件系统的具体文件系统，都会被
          抽象成文件系统设备，由该模块对其功能进行操作与管理

2、软件定时器：
     1）：当前操作系统具有简单的软件定时器，由系统时基提供定时器心跳
     2）：支持定时器对象的创建与删除，目前主要用于实现内核的 sleep 与 wakeup

3、elf 解析：
     1）：当前操作系统支持解析 elf 文件，主要用于在进程 fork 时加载磁盘文件系统
          中的进程代码
     2）：当前 elf 文件主要是通过 fs.img 文件挂载到 qemu 中后进行读写的，也就是
          当前系统所依赖的文件系统主要是 fs.img

4、虚拟内存页：
     1）：当前操作系统已支持 risc-v 内存管理单元的 Sv39 类型
     2）：在系统的 vm.c 中主要管理 mmu 模块的基本功能，包括虚拟页表的创建、
          销毁物理内存与虚拟内存的映射、不同页表数据的拷贝等等
     3）：已实现用户进程的虚拟页表管理，当系统从内核空间切换到用户空间的代码时，
          会切换相应的进程虚拟页表，确保每一个进程只执行在其有效的内存空间

5、内存管理：
     1）：当前操作系统内核空间中，支持物理内存页（4096字节）的动态申请与释放
          函数接口为： alloc_page / free_page
     2）：当前操作系统内核空间中，支持小于4096字节的物理内存的动态申请与释放
          函数接口为： kalloc / kfree 
     3）：当前操作系统用户空间中，支持小于4096字节的物理内存的动态申请与释放
          函数接口为： malloc / free 

6、权限模式切换：
     1）：当前操作系统主要适配 risc-v 架构，所以目前支持三种权限模式的管理：
          机器模式、特权级模式、用户模式
     2）：当前操作系统已实现特权模式与用户模式之间的正常切换，用户模式通过执行
          内核提供的系统调用进入内核空间
     3）：当前操作系统已支持 mmu 功能，在切换到用户模式时，会自动切换成该进程
          所拥有的虚拟页表，实现每一个进程程序的安全管理

7、用户空间：
     1）：当前操作系统将用户空间的代码与内核空间的代码进行了隔离，仅通过 qemu 
          的磁盘模块进行交互
     2）：当前系统的用户空间代码全都存放在 user 目录中，在编译过程中不与内核代码
          产生任何的交集，独立编译成对应的可执行文件
     3）：用户空间的代码通过调用 mkfs 中的磁盘文件工具，生成最终的磁盘 fs.img 文件
          件，系统内核中的磁盘文件系统对该磁盘文件进行加载与读取
     4）：用户空间若是想进入内核空间，目前只能通过内核提供的系统调用接口来进行切换

8、线程：
     1）：当前操作系统的内核线程与用户线程是一对多的关系
   内核线程：
     2）：init 进程：是操作系统的第一个用户进程，也是后续所有进程的父进程
     3）：idle 线程，是操作系统的第一个内核线程，用于处理进程的调度与死亡进程的回收
          该进程未映射相关的用户线程，只运行在操作系统的内核态中
   用户线程：
     4）：当前操作系统提供精简的用户空间线程库，包含创建、退出、等待与休眠功能
     5）：该线程的库的接口与 linux 的 pthread 类似，但目前未支持属性设置
          ( 线程库所提供的接口，可以查看 libc.h )
